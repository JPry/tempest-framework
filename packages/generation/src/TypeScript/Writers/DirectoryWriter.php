<?php

declare(strict_types=1);

namespace Tempest\Generation\TypeScript\Writers;

use Tempest\Generation\TypeScript\InterfaceDefinition;
use Tempest\Generation\TypeScript\PropertyDefinition;
use Tempest\Generation\TypeScript\TypeDefinition;
use Tempest\Generation\TypeScript\TypeScriptOutput;
use Tempest\Generation\TypeScript\TypeScriptWriter;
use Tempest\Support\Arr;
use Tempest\Support\Filesystem;
use Tempest\Support\Str;

/**
 * Writes TypeScript definitions to separate .ts files organized by namespace in a directory structure.
 */
final class DirectoryWriter implements TypeScriptWriter
{
    public function __construct(
        private readonly DirectoryTypeScriptGenerationConfig $config,
    ) {}

    public function write(TypeScriptOutput $output): void
    {
        Filesystem\ensure_directory_exists($this->config->directory);
        Filesystem\ensure_directory_empty($this->config->directory);

        $fileGroups = [];

        foreach ($output->namespaces as $namespace => $definitions) {
            $filename = $this->namespaceToFilePath($namespace);

            $fileGroups[$filename] ??= [];
            $fileGroups[$filename][$namespace] = $definitions;
        }

        foreach ($fileGroups as $filename => $namespaces) {
            Filesystem\write_file(
                filename: $filename,
                content: $this->generateFileContent($namespaces, $output),
            );
        }
    }

    /**
     * @param array<string, array<TypeDefinition|InterfaceDefinition>> $namespaces
     */
    private function generateFileContent(array $namespaces, TypeScriptOutput $output): string
    {
        $lines = [];
        $lines[] = '/*';
        $lines[] = '|----------------------------------------------------------------';
        $lines[] = '| This file contains TypeScript definitions generated by Tempest.';
        $lines[] = '|----------------------------------------------------------------';
        $lines[] = '*/';
        $lines[] = '';

        $imports = $this->collectImports($namespaces, $output);

        if ($imports !== []) {
            foreach ($imports as $import) {
                $lines[] = $import;
            }

            $lines[] = '';
        }

        foreach ($namespaces as $namespace => $definitions) {
            foreach ($definitions as $definition) {
                $lines[] = $this->generateDefinition($definition, $namespace);
                $lines[] = '';
            }
        }

        return (string) Arr\implode($lines, glue: "\n");
    }

    /**
     * @param array<string,array<TypeDefinition|InterfaceDefinition>> $namespaces
     * @return array<string>
     */
    private function collectImports(array $namespaces, TypeScriptOutput $output): array
    {
        $imports = [];
        $currentNamespaces = array_keys($namespaces);

        foreach ($namespaces as $namespace => $definitions) {
            foreach ($definitions as $definition) {
                if ($definition instanceof InterfaceDefinition) {
                    foreach ($definition->properties as $property) {
                        if ($property->fqcn === null) {
                            continue;
                        }

                        $targetNamespace = Str\before_last($property->fqcn, '\\');

                        if (in_array($targetNamespace, $currentNamespaces, strict: true)) {
                            continue;
                        }

                        $typeName = Str\after_last($property->fqcn, '\\');
                        $importPath = $this->computeImportPath($namespace, $targetNamespace);
                        $importKey = "{$importPath}::{$typeName}";

                        $imports[$importKey] ??= "import type { {$typeName} } from '{$importPath}';";
                    }
                }
            }
        }

        return array_values($imports);
    }

    private function generateDefinition(TypeDefinition|InterfaceDefinition $definition, string $currentNamespace): string
    {
        $typeName = Str\after_last($definition->class, '\\');

        if ($definition instanceof TypeDefinition) {
            return "export type {$typeName} = {$definition->definition};";
        }

        $lines = [];
        $lines[] = "export interface {$typeName} {";

        foreach ($definition->properties as $property) {
            $lines[] = sprintf(
                '  %s%s: %s;',
                $property->name,
                $property->isNullable ? '?' : '',
                $this->resolveTypeReference($property),
            );
        }

        $lines[] = '}';

        return (string) Arr\implode($lines, glue: "\n");
    }

    private function resolveTypeReference(PropertyDefinition $property): string
    {
        if ($property->fqcn === null) {
            return $property->definition;
        }

        $targetTypeName = Str\after_last($property->fqcn, '\\');
        $arrayBrackets = Str\ends_with($property->definition, '[]') ? '[]' : '';

        return $targetTypeName . $arrayBrackets;
    }

    private function namespaceToFilePath(string $namespace): string
    {
        $parts = explode('\\', $namespace);
        $kebabParts = Arr\map($parts, fn (string $part) => Str\to_kebab_case($part));
        $path = (string) Arr\implode($kebabParts, glue: '/');

        return $this->config->directory . '/' . $path . '/index.ts';
    }

    private function computeImportPath(string $sourceNamespace, string $targetNamespace): string
    {
        $sourceParts = explode('\\', $sourceNamespace);
        $targetParts = explode('\\', $targetNamespace);

        $commonLength = 0;
        $minLength = min(count($sourceParts), count($targetParts));

        for ($i = 0; $i < $minLength; $i++) {
            if ($sourceParts[$i] !== $targetParts[$i]) {
                break;
            }

            $commonLength++;
        }

        $upLevels = count($sourceParts) - $commonLength;
        $targetDiff = array_slice($targetParts, $commonLength);
        $targetKebab = Arr\map($targetDiff, fn (string $part) => Str\to_kebab_case($part));

        if ($upLevels === 0 && count($targetKebab) === 0) {
            return './';
        }

        $upPath = $upLevels > 0 ? str_repeat('../', $upLevels) : './';
        $downPath = count($targetKebab) > 0 ? (string) Arr\implode($targetKebab, glue: '/') : '';

        $fullPath = rtrim($upPath . $downPath, '/');

        return $fullPath;
    }
}

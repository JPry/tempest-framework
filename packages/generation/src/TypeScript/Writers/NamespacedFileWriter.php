<?php

declare(strict_types=1);

namespace Tempest\Generation\TypeScript\Writers;

use Tempest\Generation\TypeScript\InterfaceDefinition;
use Tempest\Generation\TypeScript\PropertyDefinition;
use Tempest\Generation\TypeScript\TypeDefinition;
use Tempest\Generation\TypeScript\TypeScriptOutput;
use Tempest\Generation\TypeScript\TypeScriptWriter;
use Tempest\Support\Arr;
use Tempest\Support\Filesystem;
use Tempest\Support\Str;

/**
 * Writes TypeScript definitions to a single .d.ts file using TypeScript namespaces.
 */
final class NamespacedFileWriter implements TypeScriptWriter
{
    public function __construct(
        private readonly NamespacedTypeScriptGenerationConfig $config,
    ) {}

    public function write(TypeScriptOutput $output): void
    {
        Filesystem\create_directory_for_file($this->config->filename);
        Filesystem\write_file($this->config->filename, $this->generateContent($output));
    }

    private function generateContent(TypeScriptOutput $output): string
    {
        $lines = [];
        $lines[] = '/*';
        $lines[] = '|----------------------------------------------------------------';
        $lines[] = '| This file contains TypeScript definitions generated by Tempest.';
        $lines[] = '|----------------------------------------------------------------';
        $lines[] = '*/';
        $lines[] = '';

        if ($output->imports !== []) {
            foreach ($output->imports as $import) {
                $lines[] = $import;
            }

            $lines[] = '';
        }

        foreach ($output->namespaces as $namespace => $definitions) {
            $lines[] = $this->generateNamespace($namespace, $definitions);
        }

        return (string) Arr\implode($lines, glue: "\n");
    }

    /**
     * @param TypeDefinition[]|InterfaceDefinition[] $definitions
     */
    private function generateNamespace(string $namespace, array $definitions): string
    {
        $lines = [];
        $lines[] = sprintf('export namespace %s {', Str\replace($namespace, '\\', '.'));

        foreach ($definitions as $definition) {
            $lines[] = $this->generateDefinition($definition);
        }

        $lines[] = '}';
        $lines[] = '';

        return (string) Arr\implode($lines, glue: "\n");
    }

    private function generateDefinition(TypeDefinition|InterfaceDefinition $definition): string
    {
        $typeName = Str\after_last($definition->class, '\\');

        if ($definition instanceof TypeDefinition) {
            return "  export type {$typeName} = {$definition->definition};";
        }

        $lines = [];
        $lines[] = "  export interface {$typeName} {";

        foreach ($definition->properties as $property) {
            $lines[] = sprintf(
                '    %s%s: %s;',
                $property->name,
                $property->isNullable ? '?' : '',
                $this->resolveTypeReference($property, $definition),
            );
        }

        $lines[] = '  }';

        return (string) Arr\implode($lines, glue: "\n");
    }

    private function resolveTypeReference(
        PropertyDefinition $property,
        InterfaceDefinition $sourceInterface,
    ): string {
        if ($property->fqcn === null) {
            return $property->definition;
        }

        $targetNamespace = Str\before_last($property->fqcn, '\\');
        $targetTypeName = Str\after_last($property->fqcn, '\\');
        $arrayBrackets = Str\ends_with($property->definition, '[]') ? '[]' : '';

        // Same namespace, use short name
        if ($sourceInterface->namespace === $targetNamespace) {
            return $targetTypeName . $arrayBrackets;
        }

        // Different namespace, relative path
        $relativePath = $this->computeRelativeNamespacePath($sourceInterface->namespace, $targetNamespace);

        return $relativePath . $targetTypeName . $arrayBrackets;
    }

    private function computeRelativeNamespacePath(string $sourceNamespace, string $targetNamespace): string
    {
        $commonLength = 0;
        $sourceParts = explode('\\', $sourceNamespace);
        $targetParts = explode('\\', $targetNamespace);
        $minLength = min(count($sourceParts), count($targetParts));

        for ($i = 0; $i < $minLength; $i++) {
            if ($sourceParts[$i] !== $targetParts[$i]) {
                break;
            }

            $commonLength++;
        }

        $targetDiff = array_slice($targetParts, $commonLength);

        if ($targetDiff === []) {
            return '';
        }

        return implode('.', $targetDiff) . '.';
    }
}
